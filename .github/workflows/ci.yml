# .github/workflows/ci.yml

name: Python Project CI # A descriptive name for your workflow

# 1. Define when the workflow should run (triggers)
on:
  push: # Run on every push event
    branches:
      - main      # Run when pushing to the 'main' branch
      - develop   # Also run when pushing to a 'develop' branch (if you use one)
      # You can add more branches or use wildcards like 'feature/*'
  pull_request: # Run when a pull request is opened or updated
    branches:
      - main      # Targeting the 'main' branch
      - develop   # Targeting the 'develop' branch

# 2. Define the jobs to be executed
jobs:
  build-and-test: # You can name this job anything descriptive
    # 3. Specify the runner environment
    runs-on: ubuntu-latest # Use a GitHub-hosted Linux runner (common and free for public repos)
                           # Other options include 'windows-latest' or 'macos-latest'

    # 4. (Optional) Define a strategy for running on multiple Python versions #test again
    strategy:
      matrix:
        python-version: ['3.11'] # Specify the Python version(s) you want to test against
                                 # If your project supports multiple, list them: ['3.9', '3.10', '3.11']

    # 5. Define the sequence of steps for the job
    steps:
      # Step 1: Check out your repository code
      - name: Checkout repository
        uses: actions/checkout@v4 # Uses a pre-built GitHub Action to get your code 

      # Step 2: Set up the specified Python version
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip' # Optional: Caches pip dependencies to speed up subsequent runs

      # Step 3: Install project dependencies (and pytest)
      - name: Install dependencies
        run: | # 'run' allows you to execute shell commands
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          # If pytest is not in requirements.txt, install it explicitly:
          # pip install pytest
          # If you use a separate dev requirements file:
          # pip install -r requirements-dev.txt

      # Step 4: (Optional but Recommended) Run a linter
      # Linters check your code for style issues and potential errors
      # - name: Lint with Flake8 (example)
      #   run: |
      #     pip install flake8
      #     # Stop the build if there are Python syntax errors or undefined names
      #     flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
      #     # exit-zero treats all errors as warnings. Use wisely.
      #     flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
      #     echo "Linting complete (if Flake8 was run)"

      # Step 5: Run your Pytest unit tests
      - name: Run Pytests
        run: |
          pytest  # This command will execute pytest
                  # Pytest will automatically discover tests in your 'tests/' directory
                  # You can add options like -v for verbose output: pytest -v

  build-test-deploy: # You can keep one job or split into build/test and deploy
    runs-on: ubuntu-latest
    env:
      HEROKU_APP_NAME: "maxime-credit-scorer-api" # !!! REPLACE with YOUR Heroku app name !!!

    strategy:
      matrix:
        python-version: ['3.11.1'] # !!! MATCH your runtime.txt EXACTLY !!!

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetches all history for all branches and tags, required by some deploy actions

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          # No need to install pytest here if it's in requirements.txt for testing

      - name: Run Pytests
        run: |
          pytest

      # --- Deployment to Heroku ---
      # This step will only run if the current event is a push to the 'main' branch
      # AND all previous steps in this job (like tests) have succeeded.
      - name: Deploy to Heroku
        if: github.event_name == 'push' && github.ref == 'refs/heads/main' && success()
        uses: akhileshns/heroku-deploy@v3.13.15 # A popular community action for Heroku deployment
        with:
          heroku_api_key: ${{ secrets.HEROKU_API_KEY }}
          heroku_app_name: ${{ env.HEROKU_APP_NAME }} # Uses the env var defined above
          heroku_email: ${{ secrets.HEROKU_EMAIL }}
          # Optional:
          # healthcheck: "https://${{ env.HEROKU_APP_NAME }}.herokuapp.com/some-health-check-endpoint" # If you have one
          # delay: 15 # Delay after deploy before healthcheck
          # rollbackonhealthcheckfailed: true
          # usedocker: false # Set to true if you were deploying a Docker image instead of Git push